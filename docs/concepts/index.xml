<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concepts on VirtualDataSet</title>
    <link>http://docs.virtdata.io/concepts/</link>
    <description>Recent content in Concepts on VirtualDataSet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://docs.virtdata.io/concepts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mapping Functions</title>
      <link>http://docs.virtdata.io/concepts/mapping_functions/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/mapping_functions/</guid>
      <description>VirtData provides more than just a set of libraries and APIs. The concepts are the starting point and foundation. The software tools are built directly from the concepts. Having a strong understanding of them will enable you to get the most out of virtual dataset.
Procedural Generation Procedural generation is a method of generating data by feeding a stream of random or pseudo-random data into an algorithm. Usually, procedural generation aims to produce content which appears original, not generated by an algorithm &amp;ndash; believably authentic by some standard.</description>
    </item>
    
    <item>
      <title>Function Graphs</title>
      <link>http://docs.virtdata.io/concepts/function_graphs/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/function_graphs/</guid>
      <description>This section should be useful to new users as well as experienced developers. Here, we explain how and why we use functions for building data mapping recipes. If you are planning to do so, this section is essential reading.
Mapping Functions A function represents a mapping between one set of values and another. Consider a basic example in which the function N(i) maps an input number to text form.</description>
    </item>
    
    <item>
      <title>Modeling Cardinality</title>
      <link>http://docs.virtdata.io/concepts/modeling_cardinality/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/modeling_cardinality/</guid>
      <description>Data Types and Values Given that our values are all bits on some level, there is no basic fixed size data type that has an unlimited range of values. Even the floating point types have finite range, although it is represented and handled differently than that of the whole number types.
Standard Types For a 64-bit data type, there are \( 64^2 \) different distinct values that can be represented.</description>
    </item>
    
    <item>
      <title>Modeling Set Relationships</title>
      <link>http://docs.virtdata.io/concepts/set_relationships/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/set_relationships/</guid>
      <description>This section will talk about how to model relative cardinality between different types of entities. Before reading this, you should already be familiar with data mapping and cardinality functions.
Suppose you have two different sets of things in your virtual dataset:
 #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type A| [&amp;lt;data&amp;gt; &amp;#34;foo&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;bar&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;baz&amp;#34;] ]    #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type B| [&amp;lt;data&amp;gt; &amp;#34;X&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Y&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Z&amp;#34;] ]   It may be the case that there is no association between elements of the first set to the second set, as illustrated above.</description>
    </item>
    
  </channel>
</rss>
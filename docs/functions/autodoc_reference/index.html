<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>All Functions - VirtualDataSet</title>
    <meta name="generator" content="Hugo 0.31" />

    
    <meta name="description" content="VirtualDataSet Docs">
    
    <link rel="canonical" href="http://docs.virtdata.io/functions/autodoc_reference/">
    

    <meta property="og:url" content="http://docs.virtdata.io/functions/autodoc_reference/">
    <meta property="og:title" content="VirtualDataSet">
    <meta property="og:image" content="/images/virtdata_128.png">
    <meta name="apple-mobile-web-app-title" content="VirtualDataSet">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">
    <link rel="icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('/fonts/icon.eot?52m981');
        src: url('/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('/fonts/icon.woff?52m981')
               format('woff'),
             url('/fonts/icon.ttf?52m981')
               format('truetype'),
             url('/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/images.css">

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,700|Roboto&#43;Mono">
    <style>
      body, input {
        font-family: 'Roboto', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Roboto Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://docs.virtdata.io/javascripts/modernizr.js"></script>

    

  
    

    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    
    
    

    
    


  </head>
  <body class="palette-primary-grey palette-accent-teal">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        All Functions
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/virtualdataset/metagen-java" title="@virtualdataset/metagen-java on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://docs.virtdata.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://docs.virtdata.io/images/virtdata_128.png">
        </div>
      
      <div class="name">
        <strong>VirtualDataSet </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    <span class="section">Introduction</span>
    <ul>
      
        
        



<a  title="Why VirtData?" href="http://docs.virtdata.io/why_virtdata/why_virtdata/">
	
	Why VirtData?
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Concepts</span>
    <ul>
      
        
        



<a  title="Mapping Functions" href="http://docs.virtdata.io/concepts/mapping_functions/">
	
	Mapping Functions
</a>



      
        
        



<a  title="Function Graphs" href="http://docs.virtdata.io/concepts/function_graphs/">
	
	Function Graphs
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Modeling Datasets</span>
    <ul>
      
        
        



<a  title="Cardinality" href="http://docs.virtdata.io/modeling_datasets/modeling_cardinality/">
	
	Cardinality
</a>



      
        
        



<a  title="Set Relationships" href="http://docs.virtdata.io/modeling_datasets/set_relationships/">
	
	Set Relationships
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Syntax Reference</span>
    <ul>
      
        
        



<a  title="Syntax Reference" href="http://docs.virtdata.io/syntax/syntax_overview/">
	
	Syntax Reference
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Function Reference</span>
    <ul>
      
        
        



<a  title="All Functions" href="http://docs.virtdata.io/functions/autodoc_reference/">
	
	All Functions
</a>



      
    </ul>
  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>All Functions </h1>

			

<p>Reference Format</p>

<p>Each heading in this page is the name of a function. The description of
the function in general is provided, if any after it.</p>

<p>The details that follow show all of the forms of the function which are available,
according to different input, out, and argument signatures. For each form,
examples and notes are provided if available under <em>ex:</em> and <em>notes:</em>.</p>

<p>Here is a fake documentation entry that visually explains the layout:</p>

<p><strong>AnyFunc (not a real function)</strong></p>

<p>The explanation of what AnyFunc does goes here. It will explain the general purpose of AnyFunc,
regardless of the type-specific details that may go below.</p>

<ul>
<li>int -&gt; AnyFunc(int: size) -&gt; int <em>(This is the full type signature of one of the availabler versions of AnyFunc)</em>

<ul>
<li><em>ex:</em> <code>AnyFunc(42)</code> - <em>An example to the left, and an explanation for what makes it useful.</em></li>
<li><em>notes:</em> This particular explanation is just to show where additional notes on the AnyFunc(int) variant would go.</li>
</ul></li>
<li>long -&gt; AnyFunc(long: size) -&gt; long <em>(There is another form available which specializes for the long type.)</em>

<ul>
<li><em>ex:</em> <code>AnyFunc(42L)</code> - <em>This form wants the argument to be a long</em></li>
</ul></li>
</ul>

<h2 id="add">Add</h2>

<p>Adds a value to the input.</p>

<ul>
<li>long -&gt; Add(long: addend) -&gt; long</li>
<li>int -&gt; Add(int: addend) -&gt; int

<ul>
<li><em>ex:</em> <code>Add(23)</code> - <em>adds integer 23 to the input integer value</em></li>
</ul></li>
<li>long -&gt; Add(long: addend) -&gt; int</li>
<li>double -&gt; Add(double: addend) -&gt; double</li>
</ul>

<h2 id="addcyclerange">AddCycleRange</h2>

<p>Adds a cycle range to the input, producing an increasing sawtooth-like output.</p>

<ul>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>int -&gt; AddCycleRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddCycleRange(int: minValue, int: maxValue) -&gt; int</li>
<li>long -&gt; AddCycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddCycleRange(long: minValue, long: maxValue) -&gt; long</li>
</ul>

<h2 id="addhashrange">AddHashRange</h2>

<p>Adds a pseudo-random value within the specified range to the input.</p>

<ul>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; int</li>
<li>long -&gt; AddHashRange(long: maxValue) -&gt; long</li>
<li>long -&gt; AddHashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; AddHashRange(int: maxValue) -&gt; int</li>
<li>int -&gt; AddHashRange(int: minValue, int: maxValue) -&gt; int</li>
</ul>

<h2 id="aliaselementsampler">AliasElementSampler</h2>

<p>Uses the alias sampling method to encode and sample from discrete probabilities,
even over larger sets of data. This form requires a unit interval sample value
between 0.0 and 1.0. Assuming the maximal amount of memory is used for distinct
outcomes N, a memory buffer of N*16 bytes is required for this implementation,
requiring 32MB of memory for 1M entries. Not bad, eh?</p>

<p>This sampler should be shared between threads, and will be by default, in order
to avoid many instances of a 32MB buffer on heap.</p>

<ul>
<li>double -&gt; AliasElementSampler(double[]: biases, T[]: elements) -&gt; T

<ul>
<li><em>notes:</em> Setup an alias table for T type objects.</li>
</ul></li>
<li>double -&gt; AliasElementSampler(java.util.Collection<T>: elements, java.util.function.Function<T,Double>: weightFunction) -&gt; T</li>
<li>double -&gt; AliasElementSampler(java.util.List<io.virtdata.stathelpers.ElemProbD<T>&gt;: events) -&gt; T</li>
</ul>

<h2 id="aliassamplerdoubleint">AliasSamplerDoubleInt</h2>

<p>Uses the alias sampling method to encode and sample from discrete probabilities,
even over larger sets of data. This form requires a unit interval sample value
between 0.0 and 1.0. Assuming the maximal amount of memory is used for distinct
outcomes N, a memory buffer of N*16 bytes is required for this implementation,
requiring 32MB of memory for 1M entries. Not bad, eh?</p>

<p>This sampler should be shared between threads, and will be by default, in order
to avoid many instances of a 32MB buffer on heap.</p>

<ul>
<li>double -&gt; AliasSamplerDoubleInt(java.nio.ByteBuffer: stats) -&gt; int</li>
<li>double -&gt; AliasSamplerDoubleInt(java.util.List<io.virtdata.stathelpers.EvProbD>: events) -&gt; int</li>
</ul>

<h2 id="alphanumericstring">AlphaNumericString</h2>

<ul>
<li>long -&gt; AlphaNumericString(int: length) -&gt; String</li>
</ul>

<h2 id="clear">Clear</h2>

<p>Clears the per-thread map which is used by the Expr function.</p>

<ul>
<li>long -&gt; Clear() -&gt; long

<ul>
<li><em>notes:</em> Clear all named entries from the per-thread map.</li>
<li><em>ex:</em> <code>Clear()</code> - <em>clear all thread-local variables</em></li>
</ul></li>
<li>long -&gt; Clear(String[]&hellip;: names) -&gt; long

<ul>
<li><em>notes:</em> Clear the specified names from the per-thread map.</li>
<li><em>ex:</em> <code>Clear('foo')</code> - <em>clear the thread-local variable &lsquo;foo&rsquo;</em></li>
<li><em>ex:</em> <code>Clear('foo','bar')</code> - <em>clear the thread-local variables &lsquo;foo&rsquo; and &lsquo;bar&rsquo;</em></li>
</ul></li>
</ul>

<h2 id="combinations">Combinations</h2>

<p>Convert a numeric value into a code according to ASCII printable
characters. This is useful for creating various encodings using different
character ranges, etc.</p>

<p>This mapper can map over the sequences of character ranges providing every unique
combination and then wrapping around to the beginning again.
It can convert between character bases with independent radix in each position.
Each position in the final string takes its values from a position-specific
character set, described by the shorthand in the examples below.</p>

<p>The constructor will throw an error if the number of combinations exceeds that
which can be represented in a long value. (This is a very high
number).</p>

<ul>
<li>long -&gt; Combinations(String: spec) -&gt; String

<ul>
<li><em>ex:</em> <code>Combinations('A-Z;A-Z')</code> - <em>a two digit alphanumeric code. Wraps at 26^2</em></li>
<li><em>ex:</em> <code>Combinations('0-9A-F')</code> - <em>a single hexadecimal digit</em></li>
<li><em>ex:</em> <code>Combinations('0123456789ABCDEF')</code> - <em>a single hexadecimal digit</em></li>
<li><em>ex:</em> <code>Combinations('0-9A-F;0-9A-F;0-9A-F;0-9A-F;')</code> - <em>two bytes of hexadecimal</em></li>
<li><em>ex:</em> <code>Combinations('A-9')</code> - <em>upper case alphanumeric</em></li>
</ul></li>
</ul>

<h2 id="cyclerange">CycleRange</h2>

<p>Yields a value within a specified range, which rolls over continuously.</p>

<ul>
<li>long -&gt; CycleRange(long: maxValue) -&gt; long</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; long</li>
<li>long -&gt; CycleRange(long: maxValue) -&gt; int</li>
<li>long -&gt; CycleRange(long: minValue, long: maxValue) -&gt; int</li>
<li>int -&gt; CycleRange(int: maxValue) -&gt; int

<ul>
<li><em>notes:</em> Sets the maximum value of the cycle range. The minimum is default to 0.</li>
<li><em>ex:</em> <code>CycleRange(34)</code> - <em>add a rotating value between 0 and 34 to the input</em></li>
</ul></li>
<li>int -&gt; CycleRange(int: minValue, int: maxValue) -&gt; int

<ul>
<li><em>notes:</em> Sets the minimum and maximum value of the cycle range.</li>
</ul></li>
</ul>

<h2 id="directorylines">DirectoryLines</h2>

<ul>
<li>long -&gt; DirectoryLines(String: basepath, String: namePattern) -&gt; String</li>
</ul>

<h2 id="div">Div</h2>

<ul>
<li>long -&gt; Div(int: divisor) -&gt; int</li>
<li>int -&gt; Div(int: divisor) -&gt; int</li>
<li>long -&gt; Div(int: divisor) -&gt; long</li>
<li>double -&gt; Div(double: divisor) -&gt; double</li>
</ul>

<h2 id="dividetolongtostring">DivideToLongToString</h2>

<p>Integer devide the cycle, the other side of modulo.</p>

<ul>
<li>long -&gt; DivideToLongToString(long: divisor) -&gt; String</li>
</ul>

<h2 id="doubletofloat">DoubleToFloat</h2>

<ul>
<li>double -&gt; DoubleToFloat() -&gt; Float</li>
</ul>

<h2 id="expr">Expr</h2>

<p>Allow for the use of arbitrary expressions according to the
<a href="http://mvel.documentnode.com/">MVEL</a> expression language.</p>

<p>Variables that have been set by a Save function are available
to be used in this function.</p>

<p>The variable name <strong>cycle</strong> is reserved, and is always equal to
the current input value.</p>

<ul>
<li>int -&gt; Expr(String: expr) -&gt; int</li>
<li>long -&gt; Expr(String: expr) -&gt; int</li>
<li>double -&gt; Expr(String: expr) -&gt; double</li>
<li>long -&gt; Expr(String: expr) -&gt; long</li>
</ul>

<h2 id="femalefirstnames">FemaleFirstNames</h2>

<ul>
<li>null -&gt; FemaleFirstNames() -&gt; null</li>
</ul>

<h2 id="fieldextractor">FieldExtractor</h2>

<p>Extracts out a set of fields from a delimited string, returning
a string with the same delimiter containing only the specified fields.</p>

<ul>
<li>String -&gt; FieldExtractor(String: fields) -&gt; String</li>
</ul>

<h2 id="firstnames">FirstNames</h2>

<p>Returns a first name from all names that were seen more than 100 times in the last census,
according to the frequency that it was actually seen.
This function does <em>not</em> pre-hash its input. You need to provide a form of hashing using
any of the documented Hash functions first.</p>

<ul>
<li>null -&gt; FirstNames() -&gt; null

<ul>
<li><em>ex:</em> <code>FirstNames()</code></li>
</ul></li>
</ul>

<h2 id="fixedvalue">FixedValue</h2>

<p>Yield a fixed value.</p>

<ul>
<li>long -&gt; FixedValue(int: value) -&gt; int

<ul>
<li><em>ex:</em> <code>FixedValue(42)</code> - <em>always return 42</em></li>
</ul></li>
<li>long -&gt; FixedValue(long: fixedValue) -&gt; long</li>
</ul>

<h2 id="fixedvalues">FixedValues</h2>

<ul>
<li>long -&gt; FixedValues(long[]&hellip;: values) -&gt; long</li>
<li>long -&gt; FixedValues(int[]&hellip;: values) -&gt; int</li>
</ul>

<h2 id="format">Format</h2>

<ul>
<li>Object -&gt; Format(String: format) -&gt; String</li>
</ul>

<h2 id="fullhash">FullHash</h2>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output.</p>

<p>This version returns the value regardless of this sign bit.
It does not return the absolute value, as Hash does.</p>

<ul>
<li>long -&gt; FullHash() -&gt; long</li>
</ul>

<h2 id="fullnames">FullNames</h2>

<ul>
<li>null -&gt; FullNames() -&gt; null</li>
</ul>

<h2 id="functemplate">FuncTemplate</h2>

<ul>
<li>long -&gt; FuncTemplate(String: rawTemplate) -&gt; String</li>
</ul>

<h2 id="hash">Hash</h2>

<p>This uses the Murmur3F (64-bit optimized) version of Murmur3,
not as a checksum, but as a simple hash. It doesn&rsquo;t bother
pushing the high-64 bits of input, since it only uses the lower
64 bits of output. It does, however, return the absolute value.
This is to make it play nice with users and other libraries.</p>

<ul>
<li>long -&gt; Hash() -&gt; long</li>
<li>int -&gt; Hash() -&gt; int</li>
<li>long -&gt; Hash() -&gt; int</li>
</ul>

<h2 id="hashrange">HashRange</h2>

<ul>
<li>long -&gt; HashRange(long: width) -&gt; long</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; long</li>
<li>int -&gt; HashRange(int: width) -&gt; int</li>
<li>int -&gt; HashRange(int: minValue, int: maxValue) -&gt; int</li>
<li>long -&gt; HashRange(long: width) -&gt; int</li>
<li>long -&gt; HashRange(long: minValue, long: maxValue) -&gt; int</li>
</ul>

<h2 id="hashrangescaled">HashRangeScaled</h2>

<p>Uses the input value as well to establish the upper bound of the
value produced from the hash.</p>

<ul>
<li>long -&gt; HashRangeScaled() -&gt; int</li>
<li>long -&gt; HashRangeScaled() -&gt; long</li>
<li>int -&gt; HashRangeScaled() -&gt; int</li>
</ul>

<h2 id="hasheddoublerange">HashedDoubleRange</h2>

<p>This simulates a uniform sample from a range of double values
via long hashing. This function attempts to take a double
unit interval value from a long/long division over the whole
range of long values but via double value types, thus providing
a very linear sample. This means that the range of double
values to be accessed will not fall along all possible doubles,
but will still provide suitable values for ranges close to
high-precision points in the IEEE floating point number line.
This suffices for most reasonable ranges in practice outside
of scientific computing, where large exponents put adjacent
IEEE floating point values much further apart.</p>

<p>This should be consider the default double range sampling
function for most uses, when the exponent is not needed for
readability.</p>

<ul>
<li>long -&gt; HashedDoubleRange(double: min, double: max) -&gt; double</li>
</ul>

<h2 id="hashedfileextracttostring">HashedFileExtractToString</h2>

<ul>
<li>long -&gt; HashedFileExtractToString(String: fileName, int: minsize, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedlinetoint">HashedLineToInt</h2>

<ul>
<li>long -&gt; HashedLineToInt(String: filename) -&gt; int</li>
</ul>

<h2 id="hashedlinetostring">HashedLineToString</h2>

<ul>
<li>long -&gt; HashedLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="hashedlinetostringlist">HashedLineToStringList</h2>

<ul>
<li>long -&gt; HashedLineToStringList(String: filename, int: minSize, int: maxSize) -&gt; java.util.List</li>
</ul>

<h2 id="hashedlinetostringset">HashedLineToStringSet</h2>

<ul>
<li>long -&gt; HashedLineToStringSet(String: filename, int: minSize, int: maxSize) -&gt; java.util.Set<String></li>
</ul>

<h2 id="hashedlinetostringstringmap">HashedLineToStringStringMap</h2>

<ul>
<li>long -&gt; HashedLineToStringStringMap(String: paramFile, int: maxSize) -&gt; java.util.Map<String,String></li>
</ul>

<h2 id="hashedlinestokeyvaluestring">HashedLinesToKeyValueString</h2>

<ul>
<li>long -&gt; HashedLinesToKeyValueString(String: paramFile, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedloremextracttostring">HashedLoremExtractToString</h2>

<ul>
<li>long -&gt; HashedLoremExtractToString(int: minsize, int: maxsize) -&gt; String</li>
</ul>

<h2 id="hashedrangedtononuniformdouble">HashedRangedToNonuniformDouble</h2>

<p>This provides a random sample of a double in a range, without
accounting for the non-uniform distribution of IEEE double representation.
This means that values closer to high-precision areas of the IEEE spec
will be weighted higher in the output. However, NaN and positive and
negative infinity are filtered out via oversampling. Results are still
stable for a given input value.</p>

<ul>
<li>null -&gt; HashedRangedToNonuniformDouble(long: min, long: max) -&gt; null</li>
<li>null -&gt; HashedRangedToNonuniformDouble(long: min, long: max, long: seed) -&gt; null</li>
</ul>

<h2 id="hashedtobytebuffer">HashedToByteBuffer</h2>

<p>Hash a long input value into a byte buffer, at least length bytes long, but aligned on 8-byte
boundary;</p>

<ul>
<li>long -&gt; HashedToByteBuffer(int: lengthInBytes) -&gt; java.nio.ByteBuffer</li>
</ul>

<h2 id="identity">Identity</h2>

<ul>
<li>long -&gt; Identity() -&gt; long</li>
</ul>

<h2 id="interpolate">Interpolate</h2>

<ul>
<li>long -&gt; Interpolate(double[]&hellip;: value) -&gt; long

<ul>
<li><em>ex:</em> <code>Interpolate(0.0d,100.0d)</code> - <em>return a linear value between 0L and 100L based on input in range 0L, Long.MAX_VALUE</em></li>
<li><em>ex:</em> <code>Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d)</code> - <em>return a weighted value between 0L and 100L based on input in range 0L, Long.MAX_VALUE, where the first second and third quartiles map to 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(long[]&hellip;: value) -&gt; long</li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; long</li>
<li>long -&gt; Interpolate(double[]&hellip;: value) -&gt; double

<ul>
<li><em>ex:</em> <code>Interpolate(0.0d,100.0d) // return a linear value, 0L -&gt; 0.0D, Long.MAX_VALUE -&gt; 100.0D</code></li>
<li><em>ex:</em> <code>Interpolate(0.0d,90.0d,95.0d,98.0d,100.0d)</code> - <em>return a weighted value between 0.0D and 100.0D based on input in range 0L, Long.MAX_VALUE, where the first second and third quartiles map to 90.0D, 95.0D, and 98.0D</em></li>
</ul></li>
<li>long -&gt; Interpolate(int: resolution, double[]: lut) -&gt; double</li>
</ul>

<h2 id="jointemplate">JoinTemplate</h2>

<ul>
<li>null -&gt; JoinTemplate(String: delimiter, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; null

<ul>
<li><em>notes:</em> Creates a string template function which will concatenate the result of the
provided functions together with the provided delimiter.</li>
</ul></li>
<li>null -&gt; JoinTemplate(String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; null

<ul>
<li><em>notes:</em> Creates a string template function which will concatenate the result
of the provided function together with the delimiter, but with the
prifix prepended and the suffix appended to the final result.</li>
</ul></li>
<li>null -&gt; JoinTemplate(java.util.function.LongUnaryOperator: iterop, String: prefix, String: delimiter, String: suffix, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; null</li>
</ul>

<h2 id="lastnames">LastNames</h2>

<ul>
<li>null -&gt; LastNames() -&gt; null</li>
</ul>

<h2 id="listtemplate">ListTemplate</h2>

<ul>
<li>long -&gt; ListTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.List<String></li>
</ul>

<h2 id="load">Load</h2>

<ul>
<li>long -&gt; Load(String: name) -&gt; long

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a long value from the named variable for this thread</em></li>
</ul></li>
<li>int -&gt; Load(String: name) -&gt; int

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load an int value from the named variable for this thread</em></li>
</ul></li>
<li>Object -&gt; Load(String: name) -&gt; Object

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a Object value from the named variable for this thread</em></li>
</ul></li>
<li>double -&gt; Load(String: name) -&gt; double

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a double value from the named variable for this thread</em></li>
</ul></li>
<li>String -&gt; Load(String: name) -&gt; String

<ul>
<li><em>ex:</em> <code>Load('foo')</code> - <em>load a String value from the named variable for this thread</em></li>
</ul></li>
</ul>

<h2 id="longtobyte">LongToByte</h2>

<ul>
<li>long -&gt; LongToByte() -&gt; Byte</li>
</ul>

<h2 id="longtoshort">LongToShort</h2>

<ul>
<li>long -&gt; LongToShort() -&gt; Short</li>
</ul>

<h2 id="longtostring">LongToString</h2>

<ul>
<li>long -&gt; LongToString() -&gt; String</li>
</ul>

<h2 id="malefirstnames">MaleFirstNames</h2>

<ul>
<li>null -&gt; MaleFirstNames() -&gt; null</li>
</ul>

<h2 id="maptemplate">MapTemplate</h2>

<ul>
<li>long -&gt; MapTemplate(java.util.function.LongToIntFunction: sizeFunc, java.util.function.LongFunction<String>: keyFunc, java.util.function.LongFunction<String>: valueFunc) -&gt; java.util.Map<String,String></li>
</ul>

<h2 id="max">Max</h2>

<ul>
<li>long -&gt; Max(long: max) -&gt; long

<ul>
<li><em>ex:</em> <code>Max(42L)</code> - <em>take the value of 42L or the input, which ever is greater</em></li>
<li><em>ex:</em> <code>Max(-42L)</code> - <em>take the value of -42L or the input, which ever is greater</em></li>
</ul></li>
<li>int -&gt; Max(int: max) -&gt; int</li>
<li>double -&gt; Max(double: max) -&gt; double</li>
</ul>

<h2 id="min">Min</h2>

<ul>
<li>long -&gt; Min(long: min) -&gt; long</li>
<li>int -&gt; Min(int: min) -&gt; int</li>
<li>double -&gt; Min(double: min) -&gt; double</li>
</ul>

<h2 id="mod">Mod</h2>

<ul>
<li>int -&gt; Mod(int: modulo) -&gt; int</li>
<li>long -&gt; Mod(long: modulo) -&gt; int</li>
<li>long -&gt; Mod(long: modulo) -&gt; long</li>
</ul>

<h2 id="modulolinetostring">ModuloLineToString</h2>

<ul>
<li>long -&gt; ModuloLineToString(String: filename) -&gt; String</li>
</ul>

<h2 id="modulotobigdecimal">ModuloToBigDecimal</h2>

<ul>
<li>long -&gt; ModuloToBigDecimal() -&gt; java.math.BigDecimal</li>
<li>long -&gt; ModuloToBigDecimal(long: modulo) -&gt; java.math.BigDecimal</li>
</ul>

<h2 id="modulotobigint">ModuloToBigInt</h2>

<ul>
<li>long -&gt; ModuloToBigInt() -&gt; java.math.BigInteger</li>
<li>long -&gt; ModuloToBigInt(long: modulo) -&gt; java.math.BigInteger</li>
</ul>

<h2 id="modulotoboolean">ModuloToBoolean</h2>

<ul>
<li>long -&gt; ModuloToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="modulotobyte">ModuloToByte</h2>

<ul>
<li>long -&gt; ModuloToByte(long: modulo) -&gt; Byte</li>
</ul>

<h2 id="modulotointeger">ModuloToInteger</h2>

<ul>
<li>long -&gt; ModuloToInteger(int: modulo) -&gt; Integer</li>
</ul>

<h2 id="modulotolong">ModuloToLong</h2>

<ul>
<li>long -&gt; ModuloToLong(long: modulo) -&gt; long</li>
</ul>

<h2 id="modulotoshort">ModuloToShort</h2>

<ul>
<li>long -&gt; ModuloToShort(long: modulo) -&gt; Short</li>
</ul>

<h2 id="mul">Mul</h2>

<ul>
<li>long -&gt; Mul(long: multiplicand) -&gt; int</li>
<li>double -&gt; Mul(double: factor) -&gt; double</li>
<li>long -&gt; Mul(long: multiplicand) -&gt; long</li>
<li>int -&gt; Mul(int: addend) -&gt; int</li>
</ul>

<h2 id="murmur3divtolong">Murmur3DivToLong</h2>

<ul>
<li>long -&gt; Murmur3DivToLong(long: divisor) -&gt; long</li>
</ul>

<h2 id="murmur3divtostring">Murmur3DivToString</h2>

<ul>
<li>long -&gt; Murmur3DivToString(long: divisor) -&gt; String</li>
</ul>

<h2 id="numbernametostring">NumberNameToString</h2>

<ul>
<li>long -&gt; NumberNameToString() -&gt; String</li>
</ul>

<h2 id="prefix">Prefix</h2>

<p>Created by sebastianestevez on 8/28/17.</p>

<ul>
<li>String -&gt; Prefix(String: prefix) -&gt; String</li>
</ul>

<h2 id="save">Save</h2>

<p>Save the current input value at this point in the function chain to a thread-local variable name.
The input value is unchanged, and available for the next function in the chain to use as-is.</p>

<ul>
<li>String -&gt; Save(String: name) -&gt; String

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current String value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>Object -&gt; Save(String: name) -&gt; Object

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current input object value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>long -&gt; Save(String: name) -&gt; long

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current long value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>int -&gt; Save(String: name) -&gt; int

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current int value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
<li>double -&gt; Save(String: name) -&gt; double

<ul>
<li><em>ex:</em> <code>Save('foo')</code> - <em>save the current double value to the name &lsquo;foo&rsquo; in this thread</em></li>
</ul></li>
</ul>

<h2 id="scale">Scale</h2>

<p>Scale the input to the</p>

<ul>
<li>long -&gt; Scale(double: scaleFactor) -&gt; long</li>
<li>long -&gt; Scale(double: scaleFactor) -&gt; int</li>
<li>int -&gt; Scale(double: scaleFactor) -&gt; int</li>
</ul>

<h2 id="show">Show</h2>

<p>Show diagnostic values for the thread-local variable map.</p>

<ul>
<li>Object -&gt; Show() -&gt; String

<ul>
<li><em>ex:</em> <code>Show()</code> - <em>Show all values in a json-like format</em></li>
</ul></li>
<li>Object -&gt; Show(String[]&hellip;: names) -&gt; String

<ul>
<li><em>ex:</em> <code>Show('foo')</code> - <em>Show only the &lsquo;foo&rsquo; value in a json-like format</em></li>
<li><em>ex:</em> <code>Show('foo','bar')</code> - <em>Show the &lsquo;foo&rsquo; and &lsquo;bar&rsquo; values in a json-like format</em></li>
</ul></li>
</ul>

<h2 id="shuffle">Shuffle</h2>

<p>This function provides a low-overhead shuffling effect without loading
elements into memory. It uses a bundled dataset of pre-computed
Galois LFSR shift register configurations, along with a down-sampling
method to provide amortized virtual shuffling with minimal memory usage.</p>

<ul>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne) -&gt; long

<ul>
<li><em>ex:</em> <code>Shuffle(11,99)</code> - <em>Provide all values between 11 and 98 inclusive, in some order, then repeat</em></li>
</ul></li>
<li>long -&gt; Shuffle(long: min, long: maxPlusOne, int: moduloSelector) -&gt; long</li>
</ul>

<h2 id="signedhash">SignedHash</h2>

<ul>
<li>int -&gt; SignedHash() -&gt; int</li>
<li>long -&gt; SignedHash() -&gt; long</li>
<li>long -&gt; SignedHash() -&gt; int</li>
</ul>

<h2 id="startingepochmillis">StartingEpochMillis</h2>

<p>This function sets the minimum long value to the equivalent
unix epoch time in milliseconds. It simply adds the input
value to this base value as determined by the provided
time specifier. It wraps any overflow within this range as well.</p>

<ul>
<li>long -&gt; StartingEpochMillis(String: baseTimeSpec) -&gt; long

<ul>
<li><em>ex:</em> <code>{StartingEpochMillis('2017-01-01 23:59:59')}</code> - <em>add the millisecond epoch time of 2017-01-01 23:59:59 to all input values</em></li>
</ul></li>
</ul>

<h2 id="staticstringmapper">StaticStringMapper</h2>

<ul>
<li>long -&gt; StaticStringMapper(String: string) -&gt; String</li>
</ul>

<h2 id="stringdatewrapper">StringDateWrapper</h2>

<ul>
<li>long -&gt; StringDateWrapper(String: format) -&gt; String</li>
</ul>

<h2 id="suffix">Suffix</h2>

<ul>
<li>String -&gt; Suffix(String: suffix) -&gt; String</li>
</ul>

<h2 id="template">Template</h2>

<p>Creates a template function which will yield a string which fits the template
provided, with all occurrences of <code>{}</code> substituted pair-wise with the
result of the provided functions. The number of <code>{}</code> entries in the template
must strictly match the number of functions or an error will be thrown.</p>

<p>To provide differing values for similarly defined functions in the list, the input
value used is automatically incremented by one for each function, starting with
the initial input value.</p>

<ul>
<li>long -&gt; Template(String: template, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>ex:</em> <code>Template('{}-{}',Add(10),Hash())</code> - <em>concatenate input+10, &lsquo;-&rsquo;, and a pseudo-random long</em></li>
</ul></li>
<li>long -&gt; Template(java.util.function.LongUnaryOperator: iterOp, String: template, java.util.function.LongFunction&lt;?&gt;[]&hellip;: funcs) -&gt; String

<ul>
<li><em>notes:</em> If an operator is provided, it is use to change the function input value in an additional way before each function.</li>
</ul></li>
</ul>

<h2 id="threadnumtointeger">ThreadNumToInteger</h2>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<ul>
<li>long -&gt; ThreadNumToInteger() -&gt; Integer</li>
</ul>

<h2 id="threadnumtolong">ThreadNumToLong</h2>

<p>Matches a digit sequence in the current thread name and caches it in a thread local.
This allows you to use any intentionally indexed thread factories to provide an analogue for
concurrency. Note that once the thread number is cached, it will not be refreshed. This means
you can&rsquo;t change the thread name and get an updated value.</p>

<ul>
<li>long -&gt; ThreadNumToLong() -&gt; long</li>
</ul>

<h2 id="tobigint">ToBigInt</h2>

<ul>
<li>long -&gt; ToBigInt() -&gt; java.math.BigInteger</li>
</ul>

<h2 id="toboolean">ToBoolean</h2>

<ul>
<li>Double -&gt; ToBoolean() -&gt; Boolean</li>
<li>Float -&gt; ToBoolean() -&gt; Boolean</li>
<li>Integer -&gt; ToBoolean() -&gt; Boolean</li>
<li>long -&gt; ToBoolean() -&gt; Boolean</li>
</ul>

<h2 id="tobyte">ToByte</h2>

<ul>
<li>double -&gt; ToByte() -&gt; Byte</li>
<li>double -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>Float -&gt; ToByte() -&gt; Byte</li>
<li>Float -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>long -&gt; ToByte() -&gt; Byte</li>
<li>long -&gt; ToByte(int: modulo) -&gt; Byte</li>
<li>String -&gt; ToByte() -&gt; Byte</li>
<li>Short -&gt; ToByte(int: scale) -&gt; Byte</li>
<li>Short -&gt; ToByte() -&gt; Byte</li>
<li>int -&gt; ToByte() -&gt; Byte</li>
<li>int -&gt; ToByte(int: modulo) -&gt; Byte</li>
</ul>

<h2 id="tobytebuffer">ToByteBuffer</h2>

<ul>
<li>Float -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>Short -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>long -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>int -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>String -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
<li>double -&gt; ToByteBuffer() -&gt; java.nio.ByteBuffer</li>
</ul>

<h2 id="todate">ToDate</h2>

<ul>
<li>long -&gt; ToDate(int: spacing, int: repeat_count) -&gt; java.util.Date</li>
<li>long -&gt; ToDate(int: spacing) -&gt; java.util.Date</li>
<li>long -&gt; ToDate() -&gt; java.util.Date</li>
</ul>

<h2 id="todatetime">ToDateTime</h2>

<ul>
<li>long -&gt; ToDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="todouble">ToDouble</h2>

<ul>
<li>long -&gt; ToDouble() -&gt; double</li>
</ul>

<h2 id="toepochtimeuuid">ToEpochTimeUUID</h2>

<p>Converts a long UTC timestamp in epoch millis form into a Version 1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This means that only one unique value for a timeuuid can be generated for
each epoch milli value, even though version 1 TimeUUIDs can normally represent
up to 10000 distinct values per millisecond. If you need to access this
level of resolution for testing purposes, use ToFinestTimeUUID
instead. This method is to support simple mapping to natural timestamps
as we often find in the real world.</p>

<p>For the variants that have an String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:
<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd&rsquo;T&rsquo;HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol></p>

<ul>
<li>long -&gt; ToEpochTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</li>
<li><em>ex:</em> <code>ToEpochTimeUUID()</code> - <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID(5234)</code> - <em>basetime 0, specified node data (5234), empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID(31,337)</code> - <em>basetime 0, specified node data (31) and clock data (337)</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('2017-01-01T23:59:59')</code> - <em>specified basetime, computed node data, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('2012',12345)</code> - <em>basetime at start if 2012, with node data 12345, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToEpochTimeUUID(String: baseSpec, long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToEpochTimeUUID('20171231T1015.243',123,456)</code> - <em>ms basetime, specified node and clock data</em></p></li>
</ul></li>
</ul>

<h2 id="tofinesttimeuuid">ToFinestTimeUUID</h2>

<p>Converts a count of 100ns intervals from 1582 Julian to a Type1 TimeUUID
according to <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
This allows you to access the finest unit of resolution for the
purposes of simulating a large set of unique timeuuid values. This offers
10000 times more unique values per ms than ToEpochTimeUUID.</p>

<p>For the variants that have an String argument in the constructor, this is
a parsable datetime that is used as the base time for all produced values.
Setting this allows you to set the start of the time range for all timeuuid
values produced. All times are parsed for UTC. All time use ISO date ordering,
meaning that the most significant fields always go before the others.</p>

<p>The valid formats, in joda specifier form are:</p>

<ol>
<li>yyyy-MM-dd HH:mm:ss.SSSZ, for example: 2015-02-28 23:30:15.223</li>
<li>yyyy-MM-dd HH:mm:ss, for example 2015-02-28 23:30:15</li>
<li>yyyyMMdd'T'HHmmss.SSSZ, for example: 20150228T233015.223</li>
<li>yyyyMMdd'T'HHmmssZ, for example: 20150228T233015</li>
<li>yyyy-MM-dd, for example: 2015-02-28</li>
<li>yyyyMMdd, for example: 20150228</li>
<li>yyyyMM, for example: 201502</li>
<li>yyyy, for example: 2015</li>
</ol>

<ul>
<li>long -&gt; ToFinestTimeUUID() -&gt; java.util.UUID

<ul>
<li><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</li>
<li><em>ex:</em> <code>ToFinestTimeUUID()</code> - <em>basetime 0, computed node data, empty clock data</em></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID(5234)</code> - <em>basetime 0, specified node data (5234), empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID(31,337)</code> - <em>basetime 0, specified node data (31) and clock data (337)</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a per-host node and empty clock data.
The node and clock components are seeded from network interface data. In this case,
the clock data is not seeded uniquely.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('2017-01-01T23:59:59')</code> - <em>specified basetime, computed node data, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and empty clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('2012',12345)</code> - <em>basetime at start if 2012, with node data 12345, empty clock data</em></p></li>
</ul></li>

<li><p>long -&gt; ToFinestTimeUUID(String: baseTimeSpec, long: node, long: clock) -&gt; java.util.UUID</p>

<ul>
<li><p><em>notes:</em> Create version 1 timeuuids with a specific static node and specific clock data.
This is useful for testing so that you can know that values are verifiable, even though
in non-testing practice, you would rely on some form of entropy per-system to provide
more practical dispersion of values over reboots, etc.</p></li>

<li><p><em>ex:</em> <code>ToFinestTimeUUID('20171231T1015.243',123,456)</code> - <em>ms basetime, specified node and clock data</em></p></li>
</ul></li>
</ul>

<h2 id="tofloat">ToFloat</h2>

<ul>
<li>double -&gt; ToFloat(double: scale) -&gt; Float</li>
<li>double -&gt; ToFloat() -&gt; Float</li>
<li>long -&gt; ToFloat(long: scale) -&gt; Float</li>
<li>long -&gt; ToFloat() -&gt; Float</li>
<li>String -&gt; ToFloat() -&gt; Float</li>
<li>int -&gt; ToFloat(int: scale) -&gt; Float</li>
<li>int -&gt; ToFloat() -&gt; Float</li>
<li>Short -&gt; ToFloat() -&gt; Float</li>
</ul>

<h2 id="tohasheduuid">ToHashedUUID</h2>

<p>This function provides a stable hashing of the input value to
a version 4 (Random) UUID.</p>

<ul>
<li>long -&gt; ToHashedUUID() -&gt; java.util.UUID</li>
</ul>

<h2 id="toinetaddress">ToInetAddress</h2>

<ul>
<li>long -&gt; ToInetAddress() -&gt; java.net.InetAddress</li>
</ul>

<h2 id="toint">ToInt</h2>

<ul>
<li>String -&gt; ToInt() -&gt; Integer</li>
<li>double -&gt; ToInt(int: scale) -&gt; int</li>
<li>double -&gt; ToInt() -&gt; int</li>
<li>long -&gt; ToInt(int: scale) -&gt; int</li>
<li>long -&gt; ToInt() -&gt; int</li>
<li>long -&gt; ToInt() -&gt; int</li>
<li>Double -&gt; ToInt(int: scale) -&gt; Integer</li>
<li>Double -&gt; ToInt() -&gt; Integer</li>
<li>Object -&gt; ToInt() -&gt; Integer</li>
</ul>

<h2 id="tojodadatetime">ToJodaDateTime</h2>

<ul>
<li>long -&gt; ToJodaDateTime(int: spacing, int: repeat_count) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime(String: spacing) -&gt; org.joda.time.DateTime</li>
<li>long -&gt; ToJodaDateTime() -&gt; org.joda.time.DateTime</li>
</ul>

<h2 id="tolong">ToLong</h2>

<ul>
<li>Float -&gt; ToLong(long: scale) -&gt; Long</li>
<li>Float -&gt; ToLong() -&gt; Long</li>
<li>double -&gt; ToLong(long: scale) -&gt; long</li>
<li>double -&gt; ToLong() -&gt; long</li>
</ul>

<h2 id="tolongfunction">ToLongFunction</h2>

<p>Adapts any FunctionalInterface type to a LongFunction,
for use with higher-order functions, when they require a
LongFunction as an argument.</p>

<ul>
<li>long -&gt; ToLongFunction(java.util.function.LongUnaryOperator: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.Function<Long,Long>: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToIntFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongToDoubleFunction: op) -&gt; Object</li>
<li>long -&gt; ToLongFunction(java.util.function.LongFunction&lt;?&gt;: func) -&gt; Object</li>
</ul>

<h2 id="tolongunaryoperator">ToLongUnaryOperator</h2>

<ul>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongFunction<Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.Function<Long,Long>: f) -&gt; long</li>
<li>long -&gt; ToLongUnaryOperator(java.util.function.LongUnaryOperator: f) -&gt; long</li>
</ul>

<h2 id="toshort">ToShort</h2>

<ul>
<li>double -&gt; ToShort() -&gt; Short</li>
<li>double -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>long -&gt; ToShort() -&gt; Short</li>
<li>long -&gt; ToShort(int: wrapat) -&gt; Short</li>
<li>String -&gt; ToShort() -&gt; Short</li>
<li>Float -&gt; ToShort() -&gt; Short</li>
<li>Float -&gt; ToShort(int: modulo) -&gt; Short</li>
<li>int -&gt; ToShort() -&gt; Short</li>
<li>int -&gt; ToShort(int: scale) -&gt; Short</li>
</ul>

<h2 id="tostring">ToString</h2>

<ul>
<li>Object -&gt; ToString() -&gt; String</li>
</ul>

<h2 id="touuid">ToUUID</h2>

<p>This function creates a non-random UUID in the type 4 version (Random).
It puts the same value in the MSB position of the UUID format.
The input value is put in the LSB position.</p>

<pre><code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx
mmmmmmmm-mmmm-Mmmm-Llll-llllllllllll
              4    3
</code></pre>

<p>As shown above, the LSB position does not have the complication of having
a version identifier (position M) dividing the dynamic range of the data type.
For this reason, only the LSB side is used for this mapper, which allows
an effective range of Long.MAX_VALUE/8, given the loss of 3 digits of precision.</p>

<ul>
<li>long -&gt; ToUUID() -&gt; java.util.UUID</li>
<li>long -&gt; ToUUID(long: msbs) -&gt; java.util.UUID</li>
</ul>

<h2 id="typeof">TypeOf</h2>

<p>Yields the class of the resulting type in String form.</p>

<ul>
<li>Object -&gt; TypeOf() -&gt; String</li>
</ul>

<h2 id="weightedstrings">WeightedStrings</h2>

<ul>
<li>long -&gt; WeightedStrings(String: valuesAndWeights) -&gt; String</li>
<li>long -&gt; WeightedStrings(String: valueColumn, String: weightColumn, String[]&hellip;: filenames) -&gt; String

<ul>
<li><em>notes:</em> Create a sampler of strings from the given CSV file. The CSV file must have plain CSV headers
as its first line.</li>
</ul></li>
</ul>


			<aside class="copyright" role="note">
				
				&copy; 2018 APL 2.0 &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="http://docs.virtdata.io/modeling_datasets/set_relationships/" title="Set Relationships">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Set Relationships
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="http://docs.virtdata.io/functions/functions_reference2/" title="">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://docs.virtdata.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>


<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>distributions - VirtualDataSet</title>
    <meta name="generator" content="Hugo 0.31" />

    
    <meta name="description" content="VirtualDataSet Docs">
    
    <link rel="canonical" href="http://docs.virtdata.io/functions/funcref_distributions/">
    

    <meta property="og:url" content="http://docs.virtdata.io/functions/funcref_distributions/">
    <meta property="og:title" content="VirtualDataSet">
    <meta property="og:image" content="/images/virtdata_128.png">
    <meta name="apple-mobile-web-app-title" content="VirtualDataSet">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">
    <link rel="icon" type="image/x-icon" href="http://docs.virtdata.io/images/engineblock_32.png">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('/fonts/icon.eot?52m981');
        src: url('/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('/fonts/icon.woff?52m981')
               format('woff'),
             url('/fonts/icon.ttf?52m981')
               format('truetype'),
             url('/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/application.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/temporary.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/palettes.css">
    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/images.css">

    <link rel="stylesheet" href="http://docs.virtdata.io/stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,700|Roboto&#43;Mono">
    <style>
      body, input {
        font-family: 'Roboto', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Roboto Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="http://docs.virtdata.io/javascripts/modernizr.js"></script>

    

  
    

    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
    
    
    

    
    


  </head>
  <body class="palette-primary-grey palette-accent-teal">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        distributions
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/virtualdataset/metagen-java" title="@virtualdataset/metagen-java on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="http://docs.virtdata.io/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="http://docs.virtdata.io/images/virtdata_128.png">
        </div>
      
      <div class="name">
        <strong>VirtualDataSet </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      

      <div class="toc">
        
        <ul>
          




<li>
  
    <span class="section">Introduction</span>
    <ul>
      
        
        



<a  title="Why VirtData?" href="http://docs.virtdata.io/why_virtdata/why_virtdata/">
	
	Why VirtData?
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Concepts</span>
    <ul>
      
        
        



<a  title="Mapping Functions" href="http://docs.virtdata.io/concepts/mapping_functions/">
	
	Mapping Functions
</a>



      
        
        



<a  title="Function Graphs" href="http://docs.virtdata.io/concepts/function_graphs/">
	
	Function Graphs
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Modeling Datasets</span>
    <ul>
      
        
        



<a  title="Cardinality" href="http://docs.virtdata.io/modeling_datasets/modeling_cardinality/">
	
	Cardinality
</a>



      
        
        



<a  title="Set Relationships" href="http://docs.virtdata.io/modeling_datasets/set_relationships/">
	
	Set Relationships
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Syntax Reference</span>
    <ul>
      
        
        



<a  title="Syntax Reference" href="http://docs.virtdata.io/syntax/syntax_overview/">
	
	Syntax Reference
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Function Reference</span>
    <ul>
      
        
        



<a  title="collections" href="http://docs.virtdata.io/functions/funcref_collections/">
	
	collections
</a>



      
        
        



<a  title="conversion" href="http://docs.virtdata.io/functions/funcref_conversion/">
	
	conversion
</a>



      
        
        



<a  title="datetime" href="http://docs.virtdata.io/functions/funcref_datetime/">
	
	datetime
</a>



      
        
        



<a  title="diagnostics" href="http://docs.virtdata.io/functions/funcref_diagnostics/">
	
	diagnostics
</a>



      
        
        



<a  title="distributions" href="http://docs.virtdata.io/functions/funcref_distributions/">
	
	distributions
</a>



      
        
        



<a  title="general" href="http://docs.virtdata.io/functions/funcref_general/">
	
	general
</a>



      
        
        



<a  title="premade" href="http://docs.virtdata.io/functions/funcref_premade/">
	
	premade
</a>



      
        
        



<a  title="state" href="http://docs.virtdata.io/functions/funcref_state/">
	
	state
</a>



      
    </ul>
  
</li>



<li>
  
    <span class="section">Site Info</span>
    <ul>
      
        
        



<a  title="Typography" href="http://docs.virtdata.io/siteinfo/typography/">
	
	Typography
</a>



      
    </ul>
  
</li>


        </ul>
        

        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>distributions </h1>

			

<h2 id="beta">Beta</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Beta_distribution">Wikipedia: Beta distribution</a></p>

<p>@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BetaDistribution.html">Commons JavaDoc: BetaDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Beta(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Beta(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="binomial">Binomial</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Binomial_distribution">Wikipedia: Binomial distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/BinomialDistribution.html">Commons JavaDoc: BinomialDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Binomial(int: trials, double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="cauchy">Cauchy</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Cauchy_distribution">Wikipedia: Cauchy_distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/CauchyDistribution.html">Commons Javadoc: CauchyDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Cauchy(double: median, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Cauchy(double: median, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="chisquared">ChiSquared</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Chi-squared_distribution">Wikipedia: Chi-squared distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ChiSquaredDistribution.html">Commons JavaDoc: ChiSquaredDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; ChiSquared(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; ChiSquared(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="constantcontinuous">ConstantContinuous</h2>

<p>Always yields the same value
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ConstantContinuousDistribution.html">Commons JavaDoc: ConstantContinuousDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; ConstantContinuous(double: value, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; ConstantContinuous(double: value, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="enumerated">Enumerated</h2>

<p>Creates a probability density given the values and optional weights provided, in &ldquo;value:weight value:weight &hellip;&rdquo; form.
The weight can be elided for any value to use the default weight of 1.0d.</p>

<p>@see <a href="http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math4/distribution/EnumeratedRealDistribution.html">Commons JavaDoc: EnumeratedRealDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Enumerated(String: data, String[]&hellip;: mods) -&gt; double

<ul>
<li><em>ex:</em> <code>Enumerated('1 2 3 4 5 6')</code> - <em>a fair six-sided die roll</em></li>
<li><em>ex:</em> <code>Enumerated('1:2.0 2 3 4 5 6')</code> - <em>an unfair six-sided die roll, where 1 has probability mass 2.0, and everything else has only 1.0</em></li>
</ul></li>
<li>long -&gt; Enumerated(String: data, String[]&hellip;: mods) -&gt; double

<ul>
<li><em>ex:</em> <code>Enumerated('1 2 3 4 5 6')</code> - <em>a fair 6-sided die</em></li>
<li><em>ex:</em> <code>Enumerated('1:2.0 2 3 4 5:0.5 6:0.5')</code> - <em>an unfair fair 6-sided die, where ones are twice as likely, and fives and sixes are half as likely</em></li>
</ul></li>
</ul>

<h2 id="exponential">Exponential</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia: Exponential distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ExponentialDistribution.html">Commons JavaDoc: ExponentialDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Exponential(double: mean, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Exponential(double: mean, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="f">F</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/F-distribution">Wikipedia: F-distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/FDistribution.html">Commons JavaDoc: FDistribution</a>
@see <a href="http://mathworld.wolfram.com/F-Distribution.html">Mathworld: F-Distribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; F(double: numeratorDegreesOfFreedom, double: denominatorDegreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="gamma">Gamma</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia: Gamma distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GammaDistribution.html">Commons JavaDoc: GammaDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Gamma(double: shape, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Gamma(double: shape, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="geometric">Geometric</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Geometric_distribution">Wikipedia: Geometric distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GeometricDistribution.html">Commons JavaDoc: GeometricDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Geometric(double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="gumbel">Gumbel</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Gumbel_distribution">Wikipedia: Gumbel distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/GumbelDistribution.html">Commons JavaDoc: GumbelDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Gumbel(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Gumbel(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="hypergeometric">Hypergeometric</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Hypergeometric_distribution">Wikipedia: Hypergeometric distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/HypergeometricDistribution.html">Commons JavaDoc: HypergeometricDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Hypergeometric(int: populationSize, int: numberOfSuccesses, int: sampleSize, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="laplace">Laplace</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Laplace_distribution">Wikipedia: Laplace distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LaplaceDistribution.html">Commons JavaDoc: LaplaceDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Laplace(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Laplace(double: mu, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="levy">Levy</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/L%C3%A9vy_distribution">Wikipedia: Lévy distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LevyDistribution.html">Commons JavaDoc: LevyDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Levy(double: mu, double: c, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Levy(double: mu, double: c, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="lognormal">LogNormal</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">Wikipedia: Log-normal distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogNormalDistribution.html">Commons JavaDoc: LogNormalDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; LogNormal(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; LogNormal(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="logistic">Logistic</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Logistic_distribution">Wikipedia: Logistic distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/LogisticDistribution.html">Commons JavaDoc: LogisticDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Logistic(double: mu, double: scale, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Logistic(double: mu, double: scale, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="nakagami">Nakagami</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Nakagami_distribution">Wikipedia: Nakagami distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NakagamiDistribution.html">Commons JavaDoc: NakagamiDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Nakagami(double: mu, double: omega, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Nakagami(double: mu, double: omega, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="normal">Normal</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Normal_distribution">Wikipedia: Normal distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/NormalDistribution.html">Commons JavaDoc: NormalDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Normal(double: mean, double: sd, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Normal(double: mean, double: sd, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="pareto">Pareto</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Pareto_distribution">Wikipedia: Pareto distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ParetoDistribution.html">Commons JavaDoc: ParetoDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Pareto(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Pareto(double: scale, double: shape, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="pascal">Pascal</h2>

<p>@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PascalDistribution.html">Commons JavaDoc: PascalDistribution</a>
@see <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Wikipedia: Negative binomial distribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Pascal(int: r, double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="poisson">Poisson</h2>

<p>@see <a href="http://en.wikipedia.org/wiki/Poisson_distribution">Wikipedia: Poisson distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/PoissonDistribution.html">Commons JavaDoc: PoissonDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Poisson(double: p, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="t">T</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Student's_t-distribution">Wikipedia: Student&rsquo;s t-distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TDistribution.html">Commons JavaDoc: TDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; T(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; T(double: degreesOfFreedom, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="triangular">Triangular</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Triangular_distribution">Wikipedia: Triangular distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/TriangularDistribution.html">Commons JavaDoc: TriangularDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Triangular(double: a, double: c, double: b, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Triangular(double: a, double: c, double: b, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="uniform">Uniform</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">Wikipedia: Uniform distribution (continuous)</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/UniformContinuousDistribution.html">Commons JavaDoc: UniformContinuousDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>int -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Uniform(double: lower, double: upper, String[]&hellip;: mods) -&gt; double</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
<li>int -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Uniform(int: lower, int: upper, String[]&hellip;: modslist) -&gt; long</li>
</ul>

<h2 id="weibull">Weibull</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia: Weibull distribution</a>
@see <a href="http://mathworld.wolfram.com/WeibullDistribution.html">Wolfram Mathworld: Weibull Distribution</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/WeibullDistribution.html">Commons Javadoc: WeibullDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function. The method used is
 inverse cumulative density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Weibull(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
<li>long -&gt; Weibull(double: alpha, double: beta, String[]&hellip;: mods) -&gt; double</li>
</ul>

<h2 id="zipf">Zipf</h2>

<p>@see <a href="https://en.wikipedia.org/wiki/Zipf's_law">Wikipedia: Zipf&rsquo;s Law</a>
@see <a href="https://commons.apache.org/proper/commons-statistics/commons-statistics-distribution/apidocs/org/apache/commons/statistics/distribution/ZipfDistribution.html">Commons JavaDoc: ZipfDistribution</a></p>

<p>Generate samples according to the specified probability density.</p>

<p>The input value consists of a long between 0L and Long.MAX_VALUE.
 This value is scaled to the unit interval (0.0, 1.0) as
 an index into a sampling function based on inverse cumulative
 density sampling.</p>

<p><H3>Sampling Mode</H3></p>

<p>The curve can be sampled in either map or hash mode. Map mode
 simply indexes into the probability curve in the order that
 it would appear on a density plot. Hash mode applies a
 murmur3 hash to the input value before scaling from the
 range of longs to the unit interval, thus providing a pseudo-random
 sample of a value from the curve. This is usually what you want,
 so hash mode is the default.  To enable map mode, simply provide
 &ldquo;map&rdquo; as one of the modifiers as explained below.</p>

<p><H3>Interpolation</H3></p>

<p>The curve can be computed from the sampling function for each value
 generated, or it can be provided via interpolation with a lookup table.
 Using interpolation makes all the generator functions perform the
 same. This is almost always what you want, so interpolation is
 enabled by default. In order to compute the value for every sample
 instead, simply provide &ldquo;compute&rdquo; as one of the modifiers as explained
 below.</p>

<p>You can add optional modifiers after the distribution parameters.
 You can add one of &lsquo;hash&rsquo; or &lsquo;map&rsquo; but not both. If neither of these is
 added, &lsquo;hash&rsquo; is implied as a default.
 You can add one of &lsquo;interpolate&rsquo; or &lsquo;compute&rsquo; but not both. If neither
 of these is added, &lsquo;interpolate&rsquo; is implied as a default.</p>

<p>At times, it might be useful to add &lsquo;hash&rsquo;, &lsquo;interpolate&rsquo; to your
 specifiers as a form of verbosity or explicit specification.</p>

<ul>
<li>int -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; int</li>
<li>int -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; long</li>
<li>long -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; int</li>
<li>long -&gt; Zipf(int: numberOfElements, double: exponent, String[]&hellip;: modslist) -&gt; long</li>
</ul>


			<aside class="copyright" role="note">
				
				&copy; 2018 APL 2.0 &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="http://docs.virtdata.io/functions/funcref_diagnostics/" title="diagnostics">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              diagnostics
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="http://docs.virtdata.io/functions/funcref_general/" title="general">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              general
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '';
      var repo_id  = '';
    
    </script>

    <script src="http://docs.virtdata.io/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "¶";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>


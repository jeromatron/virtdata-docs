<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VirtualDataSet</title>
    <link>http://docs.virtdata.io/</link>
    <description>Recent content on VirtualDataSet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>APL 2.0</copyright>
    <lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://docs.virtdata.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why VirtData?</title>
      <link>http://docs.virtdata.io/why_virtdata/why_virtdata/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/why_virtdata/why_virtdata/</guid>
      <description>If it is not real data, then what is the value of it? Virtual data is something that, when you need it, has no substitute.
To explain why, let us consider the trade-offs in some basic simulation and testing challenges and what they mean.
Speed Challenge: access large amounts of bulk data Actual Data - depends primarily on speed and efficiency of storage system - limited to size of storage system</description>
    </item>
    
    <item>
      <title>Virtual Data Set - User&#39;s Guide</title>
      <link>http://docs.virtdata.io/</link>
      <pubDate>Fri, 19 May 2017 21:52:39 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/</guid>
      <description>Please stand by while we bring the docs online&amp;hellip;
This book serves as the primary documentation for VirtualDataSet projects.
What is a Virtual DataSet? Virtual data can be described by a recipe. It can be created when you attempt to access it. Virtual Data is a lens into a set of data that may not exist yet, but which, once observed, is as tangible as stored data. Virtual data is what results when you apply a mapping function to a coordinate.</description>
    </item>
    
    <item>
      <title>Mapping Functions</title>
      <link>http://docs.virtdata.io/concepts/mapping_functions/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/mapping_functions/</guid>
      <description>VirtData provides more than just a set of libraries and APIs. The concepts are the starting point and foundation. The software tools are built directly from the concepts. Having a strong understanding of them will enable you to get the most out of virtual dataset.
Procedural Generation Procedural generation is a method of generating data by feeding a stream of random or pseudo-random data into an algorithm. Usually, procedural generation aims to produce content which appears original, not generated by an algorithm &amp;ndash; believably authentic by some standard.</description>
    </item>
    
    <item>
      <title>Function Graphs</title>
      <link>http://docs.virtdata.io/concepts/function_graphs/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/function_graphs/</guid>
      <description>This section should be useful to new users as well as experienced developers. Here, we explain how and why we use functions for building data mapping recipes. If you are planning to do so, this section is essential reading.
Mapping Functions A function represents a mapping between one set of values and another. Consider a basic example in which the function N(i) maps an input number to text form.</description>
    </item>
    
    <item>
      <title>Syntax Reference</title>
      <link>http://docs.virtdata.io/syntax/syntax_overview/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/syntax/syntax_overview/</guid>
      <description>This is a railroad schematic of the currently supported VirtData recipe syntax.
If this is your first time reading this guide, it is best to start at the top and read in order. Once you are familiar with the page, it can be used as a handy reference.
 Conventions In this documentation, CAPITALIZED := sections refer directly to a syntax type, for reference purposes. Other sections accompany the syntax diagrams, and are more explanatory in nature.</description>
    </item>
    
    <item>
      <title>Cardinality</title>
      <link>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</guid>
      <description>Data Types and Values Given that our values are all bits on some level, there is no basic fixed size data type that has an unlimited range of values. Even the floating point types have finite range, although it is represented and handled differently than that of the whole number types.
Standard Types For a 64-bit data type, there are \( 64^2 \) different distinct values that can be represented.</description>
    </item>
    
    <item>
      <title>Set Relationships</title>
      <link>http://docs.virtdata.io/modeling_datasets/set_relationships/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/set_relationships/</guid>
      <description>This section will talk about how to model relative cardinality between different types of entities. Before reading this, you should already be familiar with data mapping and cardinality functions.
Suppose you have two different sets of things in your virtual dataset:
 #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type A| [&amp;lt;data&amp;gt; &amp;#34;foo&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;bar&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;baz&amp;#34;] ]    #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type B| [&amp;lt;data&amp;gt; &amp;#34;X&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Y&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Z&amp;#34;] ]   It may be the case that there is no association between elements of the first set to the second set, as illustrated above.</description>
    </item>
    
    <item>
      <title>All Functions</title>
      <link>http://docs.virtdata.io/functions/autodoc_reference/</link>
      <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/autodoc_reference/</guid>
      <description>Reference Format Each heading in this page is the name of a function. The description of the function in general is provided, if any after it.
The details that follow show all of the forms of the function which are available, according to different input, out, and argument signatures. For each form, examples and notes are provided if available under ex: and notes:.
Here is a fake documentation entry that visually explains the layout:</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/functions/functions_reference2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/functions/functions_reference2/</guid>
      <description>mapto_hypergeometric mapto_compute_hypergeometric compute_hypergeometric uniform_integer mapto_uniform_integer mapto_compute_uniform_integer compute_uniform_integer geometric mapto_geometric mapto_compute_geometric compute_geometric poisson mapto_poisson mapto_compute_poisson compute_poisson zipf mapto_zipf mapto_compute_zipf compute_zipf binomial mapto_binomial mapto_compute_binomial compute_binomial pascal mapto_pascal mapto_compute_pascal compute_pascal levy mapto_levy mapto_compute_levy compute_levy nakagami mapto_nakagami mapto_compute_nakagami compute_nakagami triangular mapto_triangular mapto_compute_triangular compute_triangular exponential mapto_exponential mapto_compute_exponential compute_exponential logistic mapto_logistic mapto_compute_logistic compute_logistic enumerated_real mapto_enumerated_real mapto_compute_enumerated_real compute_enumerated_real laplace mapto_laplace mapto_compute_laplace compute_laplace log_normal mapto_log_normal mapto_compute_log_normal compute_log_normal cauchy mapto_cauchy mapto_compute_cauchy compute_cauchy f mapto_f mapto_compute_f compute_f t mapto_t mapto_compute_t compute_t empirical mapto_empirical mapto_compute_empirical compute_empirical normal mapto_normal mapto_compute_normal compute_normal weibull mapto_weibull mapto_compute_weibull compute_weibull chi_squared mapto_chi_squared mapto_compute_chi_squared compute_chi_squared gumbel mapto_gumbel mapto_compute_gumbel compute_gumbel beta mapto_beta mapto_compute_beta compute_beta pareto mapto_pareto mapto_compute_pareto compute_pareto gamma mapto_gamma mapto_compute_gamma compute_gamma uniform_real mapto_uniform_real mapto_compute_uniform_real compute_uniform_real Add available forms:</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</guid>
      <description>Adding a Data Mapper Library The basic recipe for adding a data mapper library to the VirtData runtime is a follows:
 Add maven dependency Implement DataMapperLibrary  If you are just wanting to provide functional classes implementing your mapping functions, simply extend &amp;hellip;  Implement your functions&amp;hellip; Add supporting documentation Add your Maven mojo to publish your library to the services manifest in META-INF/services/ Expose your library to the runtimes   In detail&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</guid>
      <description>Extending VirtData The VirtData library is not meant to be a closed system. Much of the runtime wiring was built to allow easy extension with data mapping functions of your own design. This is true at the module level as well as the individual function level.
The following sections should tell you everything you need to customize the avaialble data mapping functions for your own projects.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/library_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/library_structure/</guid>
      <description>VirtData Library Structure The data mapping functions that come with the virtdata runtime are implemented and packaged as individual libraries. They come along for the ride with the runtime artifact.
Data Mapper Libraries Each such library is known as a data mapper library, and comes with its own essential machinery:
Library Metadata The metadata for a library describes the name and purpose of the library so that users may know when and why to use it.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/matter/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/matter/glossary/</guid>
      <description>Glossary  Data Model  A model that describes the types of data that may be stored in a data set, logical or physical. It includes the types, and in some cases, the implied set of operations which are valid for accessing and manipulationg the data.  Dataset  A dataset is simply a named set of content which can be consumed, and/or modified, generally for a particular purpose. A dataset can be described by a generative model or it can be actual data that has been simulated or captured from a real world activity.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/nomnoml_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/nomnoml_test/</guid>
      <description>paragraph 1
{{#nomnoml #direction:right [f2| [ func2] [ arg2] &amp;ndash;&amp;gt; [func2] ] [ itype2] -&amp;gt; [f2] [ itype3] -&amp;gt; [f2] [f2] -&amp;gt; [ otype2] }}</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/</guid>
      <description> Coming Soon This book is a work in progress. This is an outline of upcoming sections.
 Using VirtData  Specifiers Common Recipes  Extending VirtData  Library Structure Adding a Library   - [Using VirtData](./using_virtdata/using_virtdata.md) - [Specifiers](./using_virtdata/specifiers.md) - [Common Recipes](./using_virtdata/common_recipes.md) - [Extending VirtData](./extending_virtdata/extending_virtdata.md) - [Library Structure](./extending_virtdata/library_structure.md) - [Adding a Library](./extending_virtdata/adding_libraries.md)  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/rendercheck/typography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/rendercheck/typography/</guid>
      <description>Typography This book includes some diagrams that are rendered on the client side from various graphical markup systems.
This page lets you verify that you can read the glyph and diagrams correctly. If you do not see two of everything, then you will not be able to see some of the diagrams in the book. In that case, please report the issue.
In each of the rendering checks below, the dynamically rendered element is shown first, followed by a reference image.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</guid>
      <description> Common VirtData Recipes Identity Identity()  Random Values random longs Hash()  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/specifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/specifiers/</guid>
      <description>Metagen Design 101 This serves as a basic design doc for metagen, including library integration, specifier formats, etc.
Overview Metagen&amp;rsquo;s purpose is to make a modular and composable set of procedural generation libraries that everyone can use. A succesful outcome would resemble users building complex data mapping recipes in the same spirit of adding seasonings to their favorite soup recipe.
Eventually, a rapid-prototyping feedback loop similar to the REPL concept will be supported.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</guid>
      <description>VirtData Usage TBD: restructure the section Data Mapper Library Data Mapping functions are packaged into libraries which can be loaded by the user library module of the project. Each library has its own way of providing
Function Resolver Each library must implement its own function resolver. This is because each library may have a different way of naming, finding, creating or managing function generator instances. For the user, the description of a generator is simply a string.</description>
    </item>
    
  </channel>
</rss>
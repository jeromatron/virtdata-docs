<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>VirtualDataSet</title>
    <link>http://docs.virtdata.io/</link>
    <description>Recent content on VirtualDataSet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>APL 2.0</copyright>
    <lastBuildDate>Mon, 27 Nov 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://docs.virtdata.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why VirtData?</title>
      <link>http://docs.virtdata.io/why_virtdata/why_virtdata/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/why_virtdata/why_virtdata/</guid>
      <description>If it is not real data, then what is the value of it? Virtual data is something that, when you need it, has no substitute.
To explain why, let us consider the trade-offs in some basic simulation and testing challenges and what they mean.
Speed Challenge: access large amounts of bulk data Actual Data - depends primarily on speed and efficiency of storage system - limited to size of storage system</description>
    </item>
    
    <item>
      <title>Virtual Data Set - User&#39;s Guide</title>
      <link>http://docs.virtdata.io/</link>
      <pubDate>Fri, 19 May 2017 21:52:39 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/</guid>
      <description>Please stand by while we bring the docs online&amp;hellip;
This book serves as the primary documentation for VirtualDataSet projects.
What is a Virtual DataSet? Virtual data can be described by a recipe. It can be created when you attempt to access it. Virtual Data is a lens into a set of data that may not exist yet, but which, once observed, is as tangible as stored data. Virtual data is what results when you apply a mapping function to a coordinate.</description>
    </item>
    
    <item>
      <title>Mapping Functions</title>
      <link>http://docs.virtdata.io/concepts/mapping_functions/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/mapping_functions/</guid>
      <description>VirtData provides more than just a set of libraries and APIs. The concepts are the starting point and foundation. The software tools are built directly from the concepts. Having a strong understanding of them will enable you to get the most out of virtual dataset.
Procedural Generation Procedural generation is a method of generating data by feeding a stream of random or pseudo-random data into an algorithm. Usually, procedural generation aims to produce content which appears original, not generated by an algorithm &amp;ndash; believably authentic by some standard.</description>
    </item>
    
    <item>
      <title>Function Graphs</title>
      <link>http://docs.virtdata.io/concepts/function_graphs/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/concepts/function_graphs/</guid>
      <description>This section should be useful to new users as well as experienced developers. Here, we explain how and why we use functions for building data mapping recipes. If you are planning to do so, this section is essential reading.
Mapping Functions A function represents a mapping between one set of values and another. Consider a basic example in which the function N(i) maps an input number to text form.</description>
    </item>
    
    <item>
      <title>Function Graph Kernel API</title>
      <link>http://docs.virtdata.io/sketches/function_graph_kernel_api/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/sketches/function_graph_kernel_api/</guid>
      <description>The functional graph kernel API is simply the implementation of a function graph, as realized in your application. This is the result of binding a parsed function graph template to a set of functions within a graph.
What makes the functional kernel useful are the various ways that you can interact with it. This is defined by the API.
Setting coordinates Whe a functional kernel is realized in your runtime, it will have a set of named inputs which we call coordinates.</description>
    </item>
    
    <item>
      <title>Cardinality</title>
      <link>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/modeling_cardinality/</guid>
      <description>Data Types and Values Given that our values are all bits on some level, there is no basic fixed size data type that has an unlimited range of values. Even the floating point types have finite range, although it is represented and handled differently than that of the whole number types.
Standard Types For a 64-bit data type, there are \( 64^2 \) different distinct values that can be represented.</description>
    </item>
    
    <item>
      <title>Set Relationships</title>
      <link>http://docs.virtdata.io/modeling_datasets/set_relationships/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/modeling_datasets/set_relationships/</guid>
      <description>This section will talk about how to model relative cardinality between different types of entities. Before reading this, you should already be familiar with data mapping and cardinality functions.
Suppose you have two different sets of things in your virtual dataset:
 #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type A| [&amp;lt;data&amp;gt; &amp;#34;foo&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;bar&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;baz&amp;#34;] ]    #zoom:0.75 #direction:right #.data: fill=#FFFFFF visual=frame [entity type B| [&amp;lt;data&amp;gt; &amp;#34;X&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Y&amp;#34;] [&amp;lt;data&amp;gt; &amp;#34;Z&amp;#34;] ]   It may be the case that there is no association between elements of the first set to the second set, as illustrated above.</description>
    </item>
    
    <item>
      <title>Design Sketches</title>
      <link>http://docs.virtdata.io/sketches/</link>
      <pubDate>Fri, 19 May 2017 21:51:26 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/sketches/</guid>
      <description>This section holds design sketches of some of the more esoteric design elements of EngineBlock.
 Function Graph Kernel  </description>
    </item>
    
    <item>
      <title>FGK Sketch</title>
      <link>http://docs.virtdata.io/sketches/function_graph_kernel/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/sketches/function_graph_kernel/</guid>
      <description>This section elaborates on the function graph kernel design.
Herein, the function graph kernel will be abbreviated as FGK, although it needs a better name. In essence, the function graph kernel is a runtime implementation of the Function Graph Kernel API.
Consider the following function graph. For the sake of discussion, it is assumed that this is not merely a functiong graph template, but instad a fully realized function graph kernel.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/adding_libraries/</guid>
      <description>Adding a Data Mapper Library The basic recipe for adding a data mapper library to the VirtData runtime is a follows:
 Add maven dependency Implement DataMapperLibrary  If you are just wanting to provide functional classes implementing your mapping functions, simply extend &amp;hellip;  Implement your functions&amp;hellip; Add supporting documentation Add your Maven mojo to publish your library to the services manifest in META-INF/services/ Expose your library to the runtimes   In detail&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/extending_virtdata/</guid>
      <description>Extending VirtData The VirtData library is not meant to be a closed system. Much of the runtime wiring was built to allow easy extension with data mapping functions of your own design. This is true at the module level as well as the individual function level.
The following sections should tell you everything you need to customize the avaialble data mapping functions for your own projects.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/extending_virtdata/library_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/extending_virtdata/library_structure/</guid>
      <description>VirtData Library Structure The data mapping functions that come with the virtdata runtime are implemented and packaged as individual libraries. They come along for the ride with the runtime artifact.
Data Mapper Libraries Each such library is known as a data mapper library, and comes with its own essential machinery:
Library Metadata The metadata for a library describes the name and purpose of the library so that users may know when and why to use it.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/matter/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/matter/glossary/</guid>
      <description>Glossary  Data Model  A model that describes the types of data that may be stored in a data set, logical or physical. It includes the types, and in some cases, the implied set of operations which are valid for accessing and manipulationg the data.  Dataset  A dataset is simply a named set of content which can be consumed, and/or modified, generally for a particular purpose. A dataset can be described by a generative model or it can be actual data that has been simulated or captured from a real world activity.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/src/nomnoml_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/src/nomnoml_test/</guid>
      <description>paragraph 1
{{#nomnoml #direction:right [f2| [ func2] [ arg2] &amp;ndash;&amp;gt; [func2] ] [ itype2] -&amp;gt; [f2] [ itype3] -&amp;gt; [f2] [f2] -&amp;gt; [ otype2] }}</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/</guid>
      <description> Coming Soon This book is a work in progress. This is an outline of upcoming sections.
 Using VirtData  Specifiers Common Recipes  Extending VirtData  Library Structure Adding a Library   - [Using VirtData](./using_virtdata/using_virtdata.md) - [Specifiers](./using_virtdata/specifiers.md) - [Common Recipes](./using_virtdata/common_recipes.md) - [Extending VirtData](./extending_virtdata/extending_virtdata.md) - [Library Structure](./extending_virtdata/library_structure.md) - [Adding a Library](./extending_virtdata/adding_libraries.md)  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/rendercheck/typography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/rendercheck/typography/</guid>
      <description>Typography This book includes some diagrams that are rendered on the client side from various graphical markup systems.
This page lets you verify that you can read the glyph and diagrams correctly. If you do not see two of everything, then you will not be able to see some of the diagrams in the book. In that case, please report the issue.
In each of the rendering checks below, the dynamically rendered element is shown first, followed by a reference image.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/common_recipes/</guid>
      <description> Common VirtData Recipes Identity Identity()  Random Values random longs Hash()  </description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/specifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/specifiers/</guid>
      <description>Metagen Design 101 This serves as a basic design doc for metagen, including library integration, specifier formats, etc.
Overview Metagen&amp;rsquo;s purpose is to make a modular and composable set of procedural generation libraries that everyone can use. A succesful outcome would resemble users building complex data mapping recipes in the same spirit of adding seasonings to their favorite soup recipe.
Eventually, a rapid-prototyping feedback loop similar to the REPL concept will be supported.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.virtdata.io/todo/using_virtdata/using_virtdata/</guid>
      <description>VirtData Usage TBD: restructure the section Data Mapper Library Data Mapping functions are packaged into libraries which can be loaded by the user library module of the project. Each library has its own way of providing
Function Resolver Each library must implement its own function resolver. This is because each library may have a different way of naming, finding, creating or managing function generator instances. For the user, the description of a generator is simply a string.</description>
    </item>
    
  </channel>
</rss>